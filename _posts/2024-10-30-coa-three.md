---
layout: post
title: 计算机组成原理学习笔记（三）
subtitle: Chapter 12 for review
tag: [Computer Organization and Architecture]
cover-img: /assets/img/miku.jpg
share-img: /assets/img/miku.jpg
thumbnail-img: /assets/img/miku.jpg
author: LiPtP
mathjax: true
---

{: .box-note}
This is a summary note of the course "Computer Organization and Architecture" by Professor _William Stallings_.

The remaining contents is organized as:

- Chapter 12
  - Machine Instruction Characteristics
    - Elements of a machine instruction
    - Instruction representation
    - Instruction type
    - Number of addresses
    - Instruction set design

---

# Chapter 12: Machine Instruction Characteristics

## Elements of a machine instruction

The elements of a machine instruction are:

- **Operation Code**: a binary code that specifies the operation to be performed.
- **Source operands reference**: source operands that are involved in the operation.
- **Result operands reference**: result produced by the operation.
- **Next instruction reference**: tells the processor where to **fetch the next instruction** after the instruction is executed.

Source and result operands can be in **memory**, **registers**, **I/O devices**, or **immediate values**.

Here's a diagram of a machine executing an instruction:

  <br/>
  ![Instruction Execution Diagram](/assets/img/COA-images/instruction-cycle.png){: .mx-auto.d-block :}
  <br/>

In the diagram we can find that: both the source operands and the result operands should be addressed by "Operand address calculation".

## Instruction representation

**In machine code each instruction has a unique bit pattern.** But for programmers each instruction has a symbolic representation, like ADD, SUB, AND, OR, etc. These symbolic representations are called **mnemonics**.(助记符)

Here's a diagram of common mnemonics in x86 architecture:

  <br/>
  | Mnemonic | Operation |
  | :------: | :-------: |
  | **ADD**      | Addition  |
  | **SUB**      | Subtraction |
  | **MUL**      | Multiplication |
  | **DIV**      | Division |
  | **LOAD**     | Load Data from memory |
  | **STOR**     | Store Data to memory |
  | AND      | Bitwise AND |
  | OR       | Bitwise OR |
  | XOR      | Bitwise XOR |
  | NOT      | Bitwise NOT |
  | SHL      | Shift Left |
  | SHR      | Shift Right |
  | CMP      | Compare |
  | JMP      | Jump |
  | JZ       | Jump if Zero |
  | JNZ      | Jump if Not Zero |
  | JC       | Jump if Carry |
  | JNC      | Jump if Not Carry |
  | JO       | Jump if Overflow |
  | JNO      | Jump if No Overflow |
  | JA       | Jump if Above |
  | JNA      | Jump if Not Above |
  | JAE      | Jump if Above or Equal |
  | JNAE     | Jump if Not Above or Equal |
  | JB       | Jump if Below |
  | JNB      | Jump if Not Below |
  | JBE      | Jump if Below or Equal |
  | JNBE     | Jump if Not Below or Equal |
  | CALL     | Call Subroutine |
  | RET      | Return from Subroutine |
  | PUSH     | Push onto Stack |
  | POP      | Pop from Stack |
  | LEA      | Load Effective Address |
  | MOV      | Move Data |
  | XCHG     | Exchange Data |
  | CBW      | Convert Byte to Word |
  | CWDE     | Convert Word to Doubleword |
  | CLC      | Clear Carry Flag |
  | STC      | Set Carry Flag |
  | CLD      | Clear Direction Flag |
  | STD      | Set Direction Flag |
  | HLT      | Halt |
  <br/>

Here's a common instruction mnemonic in this course:

  <br/>
  | Mnemonic | Operation |
  | :------: | :-------: |
  |
A typical 16-bit **instruction format** is: `Opcode [4 bits]| Operand Reference[6 bits] | Operand Reference[6 bits]`

## Instruction type

## Number of addresses

## Instruction set design
