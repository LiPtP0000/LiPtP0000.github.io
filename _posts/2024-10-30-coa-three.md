---
layout: post
title: 计算机组成原理学习笔记（三）
subtitle: Chapter 12 for review
tag: [Computer Organization and Architecture]
cover-img: /assets/img/miku.jpg
share-img: /assets/img/miku.jpg
thumbnail-img: /assets/img/miku.jpg
author: LiPtP
mathjax: true
---

{: .box-note}
This is a summary note of the course "Computer Organization and Architecture" by Professor _William Stallings_.

The remaining contents is organized as:

- Chapter 12
  - Machine Instruction Characteristics
    - Elements of a machine instruction
    - Instruction representation
    - Instruction type
    - Number of addresses
    - Instruction set design

---

# Chapter 12: Machine Instruction Characteristics

## Elements of a machine instruction

The elements of a machine instruction are:

- **Operation Code**: a binary code that specifies the operation to be performed.
- **Source operands reference**: source operands that are involved in the operation.
- **Result operands reference**: result produced by the operation.
- **Next instruction reference**: tells the processor where to **fetch the next instruction** after the instruction is executed.

Source and result operands can be in **memory**, **registers**, **I/O devices**, or **immediate values**.

Here's a diagram of a machine executing an instruction:

  <br/>
  ![Instruction Execution Diagram](/assets/img/COA-images/instruction-cycle.png){: .mx-auto.d-block :}
  <br/>

In the diagram we can find that: both the source operands and the result operands should be addressed by "Operand address calculation".

## Instruction representation

**In machine code each instruction has a unique bit pattern.** But for programmers each instruction has a symbolic representation, like ADD, SUB, AND, OR, etc. These symbolic representations are called **mnemonics**.(助记符)

Here's a diagram of common mnemonics in **IAS Structure** (_Mentioned in Ch1_):

| Mnemonic |       Operation       |
| :------: | :-------------------: |
| **ADD**  |       Addition        |
| **SUB**  |      Subtraction      |
| **MUL**  |    Multiplication     |
| **DIV**  |       Division        |
| **LOAD** | Load Data from memory |
| **STOR** | Store Data to memory  |

A typical 16-bit **instruction format** is:

`Opcode [4 bits]| Operand Reference[6 bits] | Operand Reference[6 bits]`

High level languages are mostly first translated into machine code, and then it could be executed by the processor.

{: .box-note}
Some compiler can directly translate high level language into machine code, like `g++` or `clang`, but some compilers first translate it into **Assembly language** and then into machine code. While languages like **Python** uses a explainer instead of a compiler, so it doesn't need to be translated into machine code.这是一个坑！！

## Instruction type

Like the concept of **_Structure Function_**, in Chapter 1, the instruction type can be separated into 4 categories (with Assembly instructions for example):

- **Data Processing**: Arithmetic and logic instructions. (ADD, SUB, AND, OR, etc.)
- **Data Storage**: Movement of data into or out of register and or memory locations.(MOV, STO, LOD, etc.)
- **Data Movement**: I/O instructions. (IN, OUT, etc.)
- **Control**: **_Test_** and **_branch_** instructions. (JMP, JC, etc.)

## Number of addresses

Four types of numbers of addresses: 3,2,1,0.

{:.box-note}
More addresses means **more complex instructions, more registers**, but less instructions in a program. Fewer addresses means **less complex instructions** and **faster fetch/execution of instructions** but more instructions in a program.

### 3-address instructions

Two sources and one result address included in the instruction. However it's not common because it needs long instruction format.

**Symbolic representation:**

```
OP A,B,C <-> A <- B OP C
```

### 2-address instructions

Compared to 3-address instructions, 2-address instructions only need one source and one address for operand + result (Multiplexing). Classical examples are:

- MOV: Move data from one location to another.
- ADD: Add two numbers and store the result in a register or memory location.
- SUB: Subtract two numbers and store the result in a register or memory location.

**Symbolic representation:**

```
OP A,B <-> A <- A OP B
```

### 1-address instructions

Only one address included in the instruction. **The second address is implicit**. Usually used as:

```
LOAD A <-> AC <- A
```

**It is usually a register or accumulator to hold an 1-address instruction.**

### 0-address instructions

Use a stack to find the operands. See the example of c=a+b below:

```assembly
push a
push b
add // pop a and b from stack and add them, push the result to stack
pop c
```

## Instruction set design
