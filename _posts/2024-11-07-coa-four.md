---
layout: post
title: 计算机组成原理学习笔记（四）
subtitle: Chapter 13 for review
tag: [Computer Organization and Architecture]
cover-img: /assets/img/miku.jpg
share-img: /assets/img/miku.jpg
thumbnail-img: /assets/img/miku.jpg
author: LiPtP
mathjax: true
---

{: .box-note}
This is a summary note of the course "Computer Organization and Architecture" by Professor _William Stallings_.

The remaining contents are organized as:

- Chapter 13
    - *Addressing Modes
    - *Instruction Format

# Chapter 13: Instruction Sets Addressing Modes and Format
## Addressing Modes
There are six typical addressing modes listed below.

- Immediate Addressing (立即数寻址)
- Direct Addressing (直接寻址)
- Indirect Addressing (间接寻址)
- Register Addressing (寄存器直接寻址)
- Register Indirect Addressing (寄存器间接寻址)
- Displacement (偏移寻址)
- Stack Addressing (栈寻址)

And here are some notations for convenience of the discussions below:

| Code | Meaning |
| :---: | :---: |
| A | contents of an address field in the instruction |
| EA | **E**ffective **A**ddress of the referenced instruction location |
| R | contents of an address field in the instruction that refers to a register |
| (X) | contents in address X |

Here's a brief summary of this.

  <br/>
  ![Instruction Execution Diagram](/assets/img/COA-images/addressingMode.png){: .mx-auto.d-block :}
  <br/>

### Immediate Addressing

Operand is a part of instruction.

**Pros**:
- Fast
- No memory reference to fetch data

**Cons**:
- limited range of operand

### Direct Addressing

**EA = A**, where EA is the address of operand, A is a part of instruction. Instead of writing **operand** directly into the instruction field in immediate addressing, direct addressing method **put the address A into it**.

{:.box-note}
How it works: First add contents of cell A to the accumulator, then look at address EA to get the operand

**Pros**: 

- Single memory reference to access data
- No additional calculations to work out effective address

**Cons**:

- Limited address space

### Indirect Addressing

**EA = (A)**, which means the operand **address** lies in **content of A**. So the process is: Look in A, find address A and look there for the real address for operand.


**Pros**:

- Large Addressing Space

**Cons**:

- Multiple Memory Access Time
- Slower

### Register (Direct) Addressing

**EA = R**, which means the operand directly lies in somewhere in **a register**, where R means the address of operand in the register. 

{:.box-success}
*Typically, an address field that references registers will have 3-5 bits, so a total of 8 to 32 registers can be referenced.*



**Pros**:

- No memory access, hence faster
- small address field is needed in the instruction.

**Cons**:

- register numbers are limited, which requires to be properly employed.

### Register Indirect Addressing

**EA = (R)**, which means the registers store the address of the operand.

**Pros**: 

- Large address space, which is $$2^n$$ bits for n-bit register.
- One fewer memory access compared to indirect addressing.

**Cons**: 

- slower
- multiple access time if there are multiple `()`


### Displacement Addressing

**EA= A + (R)**. This addressing method is mainly used in three scenarios:

1. PC Relative Addressing
2. Base Register Addressing
3. Indexing

For **PC Relative Addressing**, the *next instruction address* is added to the address field of the address field to produce the EA. Let's review the ***concept of locality***:

1. 大部分都是顺序结构；
2. 很少会有很深的call调用，程序的invocation depth很浅；
3. 循环语句中的内容（指令）往往比较少；
4. 如数组这样的数据结构一般地址聚集在一起。

So with concept of locality, the use of relative addressing save address bits in the instruction.


For **Base-register Addressing**, the register contains *the main memory address*, while the address field contains *a displacement*. The registers are mainly used as *distinguishing segments* (segmentation). It also exploits the concept of locality.

For **Indexing**, it mainly has three types:

1. Autoindexing
2. Post-indexing
3. Pre-indexing


## Instruction Format

# Problems
